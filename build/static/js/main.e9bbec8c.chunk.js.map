{"version":3,"sources":["showTime.js","Todolist/Todoing.js","Todolist/Todoinput.js","request/request.js","Todolist/Todolist.js","index.js"],"names":["Component","Todoing","this","props","a","htmlFor","style","color","type","id","className","todo","map","item","index","key","onClick","delTodo","defaultProps","Todoinput","handleInput","e","keyCode","addTodo","target","value","handleChange","setState","name","parseInt","state","n1","n2","onChange","onKeyDown","request","data","fetch","then","res","json","result","console","log","album_title","author","ele","ReactDOM","render","document","getElementById"],"mappings":"gQAEuBA,Y,MCAFC,E,iLACP,IAAD,OACL,OACI,6BACI,wDACA,2BAAIC,KAAKC,MAAMC,GAGf,2BAAOC,QAAQ,KAAKC,MAAO,CAACC,MAAM,QAAlC,iBACA,2BAAOC,KAAK,OAAOC,GAAG,OAEtB,wBAAIC,UAAU,QAENR,KAAKC,MAAMQ,KAAKC,KAAI,SAACC,EAAKC,GACtB,OAAO,wBAAIC,IAAKD,GAAQD,EAAjB,QAA2B,4BAAQG,QAAS,WAAK,EAAKb,MAAMc,QAAQH,KAAzC,0B,GAdzBd,aA2BrCC,EAAQiB,aAAe,CACnBP,KAAK,CAAC,EAAE,EAAE,GACVP,EAAE,K,YCxBee,E,YACjB,aAAc,IAAD,8BACT,+CAMJC,YAAc,SAACC,GACM,KAAdA,EAAEC,SACD,EAAKnB,MAAMoB,QAAQF,EAAEG,OAAOC,QATvB,EAYbC,aAAa,SAACL,GAEV,EAAKM,SAAL,eAEKN,EAAEG,OAAOI,KAAMC,SAASR,EAAEG,OAAOC,UAdtC,EAAKK,MAAM,CACPC,GAAG,EACHC,GAAG,GAJE,E,sEAmBH,IAAD,OACL,OACI,6BACI,2BAAOJ,KAAK,KAAKK,SAAU/B,KAAKwB,aAAcD,MAAOvB,KAAK4B,MAAMC,GAAIG,UAAW,SAACb,GAAD,OAAK,EAAKD,YAAYC,IAAIb,KAAK,SAC9G,2BAAOoB,KAAK,KAAKK,SAAU,SAACZ,GAAD,OAAK,EAAKK,aAAaL,IAAII,MAAOvB,KAAK4B,MAAME,GAAIE,UAAW,SAACb,GAAD,OAAK,EAAKD,YAAYC,IAAIb,KAAK,SACtH,2BAAIN,KAAK4B,MAAMC,GAAG7B,KAAK4B,MAAME,S,GAzBNhC,aCLlBmC,GCGiBnC,Y,kBDFlC,aAAc,IAAD,8BACT,+CACK8B,MAAQ,CACTM,KAAK,IAHA,E,iFAOO,IAAD,OAWfC,MAAM,uDAAuDC,MAAK,SAACC,GAC/D,OAAOA,EAAIC,UACZF,MAAK,SAACC,GACL,EAAKZ,SAAS,CACVS,KAAKG,EAAIE,SAEbC,QAAQC,IAAIJ,EAAIE,a,+BAKpB,OACI,6BACI,wDACA,4BAEQvC,KAAK4B,MAAMM,KAAKxB,KACZ,SAACC,EAAKC,GACN,OACI,wBAAIC,IAAKD,GACL,4CAAQD,EAAK+B,aACb,2CAAO/B,EAAKgC,kB,GAxCX7C,cESjC8C,EAAI,wBAAIrC,GAAG,MAAK,2BADV,UAEVsC,IAASC,OAAOF,EAAKG,SAASC,eAAe,SAU7CH,IAASC,OAAO,kBAAC,EAAD,MAAYC,SAASC,eAAe,W","file":"static/js/main.e9bbec8c.chunk.js","sourcesContent":["import React,{Component}from 'react';\r\n//export default class ShowTime extends Component{...} 直接导出\r\nclass ShowTime extends Component{\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            time:new Date().toLocaleTimeString()\r\n        };\r\n        \r\n    }\r\n    handleClick(num,e){\r\n        console.log('点击成功');\r\n        console.log('num',num);\r\n        console.log('event',e);\r\n        console.log('event.target',e.target)\r\n        console.log(this)\r\n    };\r\n    \r\n    divClick=(e,ev)=>{\r\n        console.log('传入的参数',e);\r\n        console.log('事件对象',ev);\r\n        console.log(this)\r\n    }\r\n    //至少有一个render方法，return 出一个值\r\n    render(){\r\n        //这样setState就会执行render() 但是construst只会执行一次\r\n        setInterval(()=>{\r\n            this.setState({\r\n                time:new Date().toLocaleTimeString()\r\n            })\r\n        },1000)\r\n        return (\r\n        <React.Fragment>\r\n            <div onClick={this.handleClick}>当前 {this.props.word}</div>\r\n            <h2>{this.state.time}</h2>\r\n            <div\r\n                onClick={(ev)=>this.handleClick(3,ev)\r\n            }>点我</div>\r\n            <div onClick={this.divClick.bind(this,2)}>传参</div>\r\n        </React.Fragment>\r\n        )// 注意  只能return一个标签  我们这里用React.Fragment只是充当一个容器，但是不会渲染出来\r\n    };\r\n}\r\n//默认导出，只能导出一次\r\nexport default ShowTime;\r\n//命名导出 可以导出多个 可写多个export\r\n//export {ShowTime};//export {a,b,c} ","import React, { Component } from 'react'\r\nimport PropTypes from 'prop-types';\r\nexport default class Todoing extends Component {\r\n    render() {\r\n        return (\r\n            <div>\r\n                <h1>正在进行</h1>\r\n                <p>{this.props.a}</p>\r\n\r\n                {/* 可以用三目运算符进行判断 */}\r\n                <label htmlFor=\"aa\" style={{color:'red'}}>输入:</label>\r\n                <input type=\"text\" id=\"aa\"/>\r\n                {/* style属性接受一个JS对象{},其属性用小驼峰命名法命名，而不是接受CSS字符串 */}\r\n                <ul className=\"list\">\r\n                    {\r\n                        this.props.todo.map((item,index)=>{\r\n                            return <li key={index}>{item}-----<button onClick={()=>{this.props.delTodo(index)}}>删除</button></li>\r\n                        })\r\n                    }\r\n                </ul>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n//检查从父组件中传入的数据类型是否和需要的数据类型相同\r\nTodoing.propTypes = {\r\n    todo:PropTypes.array\r\n}\r\n//设置默认值\r\nTodoing.defaultProps = {\r\n    todo:[5,5,6],\r\n    a:100\r\n}\r\n","import React, { Component } from 'react'\r\n\r\n//受控组件\r\n//受控组件：value值被react的状态控制\r\n//实时获取或处理输入的内容\r\n// 先用value来存一个固定的值，然后当这个值改变的时候就会调用onChange方法\r\n// 在onChange方法中使用this.setState来更新数据\r\nexport default class Todoinput extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            n1:0,\r\n            n2:0\r\n        }\r\n    }\r\n    handleInput = (e) => {\r\n        if(e.keyCode === 13){\r\n            this.props.addTodo(e.target.value)\r\n        }\r\n    }\r\n    handleChange=(e)=>{\r\n        //一个事件处理函数处理多个表单框\r\n        this.setState({\r\n            //这里是e.target.name时变量名，我们要拿到他的值\r\n            [e.target.name]:parseInt(e.target.value)\r\n        })\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <input name=\"n1\" onChange={this.handleChange} value={this.state.n1} onKeyDown={(e)=>this.handleInput(e)} type=\"text\"/>\r\n                <input name=\"n2\" onChange={(e)=>this.handleChange(e)} value={this.state.n2} onKeyDown={(e)=>this.handleInput(e)} type=\"text\"/>\r\n                <p>{this.state.n1+this.state.n2}</p>\r\n                {/* <p dangerouslySetInnerHTML={{__html:this.state.n1+this.state.n2}}></p> */}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n\r\n// import React, { Component } from 'react'\r\n\r\n// //非受控组件\r\n// //使用refs获取表单的值 ref用于访问在render方法中创建的DOM节点或React元素\r\n// export default class Todoinput extends Component {\r\n//     //思考一下，为什么要在这个函数componentDidMount中才能打印出\r\n//     componentDidMount(){\r\n//         console.log(this.inp1);//是节点\r\n//         console.log(this.inp1.value);\r\n        \r\n//     }\r\n//     search=()=>{\r\n//         console.log(this.inp1.value);\r\n//     }\r\n//     render() {\r\n//         return (\r\n//             <div>\r\n                \r\n//                  <input type=\"text\" ref={(inp)=> this.inp1 = inp}/>\r\n//                  {/* ref中的函数调用是DOM来调用 */}\r\n//                  <button onClick={this.search}>查询</button>\r\n//             </div>\r\n//         )\r\n//     }\r\n// }\r\n\r\n\r\n\r\n","import React, { Component } from 'react'\r\nimport Axios from 'axios'\r\nexport default class request extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state = {\r\n            data:[]\r\n        }\r\n    }\r\n    //在componentDidMount发请求比较好,因为会在组件挂载后（插入 DOM 树中）立即调用\r\n    componentDidMount(){\r\n        // Axios.get('https://api.apiopen.top/musicRankingsDetails?type=1')\r\n        // .then((res)=>{\r\n        //     this.setState({\r\n        //         data:res.data.result\r\n        //     })\r\n        // })\r\n\r\n        //原生 fetch请求\r\n        // 返回的是res对象，不是数据，执行res.json()才是数据\r\n        // fetch(url,{method:'post',body:'{name:111}'})\r\n        fetch('https://api.apiopen.top/musicRankingsDetails?type=1').then((res)=>{\r\n            return res.json()\r\n        }).then((res)=>{\r\n            this.setState({\r\n                data:res.result\r\n            })\r\n            console.log(res.result);\r\n        })\r\n    \r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <h1>请求接口</h1>\r\n                <ul>\r\n                    {\r\n                        this.state.data.map(\r\n                            (item,index)=>{\r\n                            return (\r\n                                <li key={index}>\r\n                                    <h2>歌名:{item.album_title}</h2>\r\n                                    <p>歌手:{item.author}</p>\r\n                                </li>\r\n                            )\r\n                            }\r\n                        )\r\n                    }\r\n                </ul>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","import React,{Component} from 'react';\r\nimport Todoing from './Todoing';\r\nimport Todoinput from './Todoinput';\r\n\r\n\r\nexport default class Todolist extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state = {\r\n            todo:[1,2,3],\r\n        }\r\n    }\r\n    addItem=(msg)=>{\r\n        this.setState({\r\n            // 展开运算符\r\n            todo:[...this.state.todo,msg]\r\n        })\r\n        console.log(msg)\r\n    }\r\n    delItem=(e)=>{\r\n        //状态 state\r\n        //1、不要直接改变，处理状态\r\n        //2、setState是异步的\r\n        \r\n\r\n        //最好不要给this.state....直接修改\r\n        //浅拷贝 共享同一块内存\r\n        //深拷贝 不共享同一块内存\r\n        //这里用深拷贝，因为展开的this.state.todo中没有引用类型，但是如果用引用类型的话，就是浅拷贝了\r\n        // [] 就是新生成了一个数组\r\n        var todo = [...this.state.todo];\r\n        todo.splice(e,1);\r\n        this.setState({\r\n            todo:todo//这里浅拷贝\r\n        })\r\n        // this.setState((state,props)=>{todo:todo})\r\n        // 这里的state拿到的上一个状态\r\n        // 下面这种情况\r\n        // this.setState({\r\n        //  todo:todo\r\n        //})\r\n\r\n        //对象的拷贝\r\n        var obj1 = {a:100};\r\n        var obj2 = {b:200}\r\n        var o = Object.assign(obj1,obj2);//assign 将多个对象合并成一个对象，并返回这个对象\r\n        console.log(o);\r\n        console.log(o === obj1);//true 没有创建出一个新的对象\r\n        console.log(obj1);\r\n\r\n        var o1 = Object.assign({},obj1,obj2);//创建一个新的对象\r\n        console.log(o1 === obj1);//false  现在创建一个新的对象\r\n\r\n        //遍历对象\r\n        //用下面这种方式，就不要用for in了\r\n        var a = {a:100,b:200};\r\n        Object.keys(a).forEach((item)=>{\r\n            console.log('Object:'+a[item])\r\n        })\r\n        \r\n        \r\n    }\r\n    //初始化 、setState 改变\r\n    //render 会被调用\r\n    render() {\r\n        return (\r\n            <div>\r\n                {/*子组件往父组件传递 \r\n                    调用子组件时往子组件传递一个函数\r\n                    子组件通过props调用该函数\r\n                */}\r\n                <Todoinput addTodo={this.addItem}/>\r\n                {/* 父组件往子组件传递 */}\r\n                <Todoing todo={this.state.todo} delTodo={this.delItem}/>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","//react\nimport React,{Component}from 'react';//这里解构拿出react.Component\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport ShowTime from './showTime';//引入自己定义的组件 默认导出 \nimport Todolist from './Todolist/Todolist';\nimport Request from './request/request';\n//import {ShowTime} from './showTime'; //命名导出\n//在js中要这样做\n//document.getElementById('root').innerHTML='<h1>你好</h1>';\nvar str = 'hello'\nvar ele=<h1 id=\"h1\"><p>{str}</p></h1>;\nReactDOM.render(ele, document.getElementById('root'));//渲染 在id=root这个dom中渲染前面的标签\n\n//组件交互\n//父组件---->子组件：调用时在子组件上添加属性 word=\"...\"\n//在子组件中通过props获取数据\n\n//子组件--->父组件：\n//ReactDOM.render(<ShowTime word=\"北京时间\"/>,document.getElementById('root'));\n\n// ReactDOM.render(<Todolist/>, document.getElementById('root'));\nReactDOM.render(<Request/>, document.getElementById('root'));\n\n\n\n/*\nvar root=document.getElementById('root');\nsetInterval(()=>{\n    root.style.width=root.offsetWidth+1+'px';//root.offsetWidth+1每次要重排一次，然后在赋值（这个无法避免）\n},100)\n*/\n\n//一个点：哪里变就渲染哪里\n/*function tick(){\n    var e = <h1>{new Date().toLocaleTimeString()}</h1>;\n    ReactDOM.render(e,document.getElementById('root'))\n}\nsetInterval(tick,1000)*/\n\n//函数定义组件 （无生命周期函数） \n//当只是渲染结构时\n/*\nvar root=document.getElementById('root');\n//用map方法来进行遍历\n//key属性 用来以后检测更新，谁不用动，谁需要动\nfunction Hello(props){\n    return (\n        <div>\n            {props.name.length>=2?<h1>To Do</h1>:''}\n            <h3>{props.name.map((item,index)=>{\n                if(index%2 === 0){\n                return <li key={item}>{item}</li>}\n            })}</h3>\n            <p>喜欢blackpink吗</p>\n        </div>\n    )\n};\nvar nice =\"老弟!\";\nvar item = ['jisoo','lisa','jennie','rose']\nReactDOM.render(<Hello name={item}/>,document.getElementById('root'))\n*/\n\n//类定义组件 (有生命周期)\n\n// class Hello extends Component{\n//     //至少有一个render方法，return 出一个值\n//     render(){\n//         return <div> blackpink {this.props.word}</div>//this....类当中的一个属性\n//     }\n// }\n// ReactDOM.render(<Hello word=\" 一直走花路\"/>,document.getElementById('root'))\n\n/*基础结构\nclass Hello extends Component{\n    constructor(){}\n    render(){}\n}\n*/\n/*\nclass Hello extends Component{\n    constructor(){\n        super();\n        this.state={\n            time:new Date().toLocaleTimeString()\n        };\n        \n    }\n    //至少有一个render方法，return 出一个值\n    render(){\n        //这样setState就会执行render() 但是construst只会执行一次\n        setInterval(()=>{\n            this.setState({\n                time:new Date().toLocaleTimeString()\n            })\n        },1000)\n        return (\n        <React.Fragment>\n            <div> blackpink {this.props.word}</div>\n            <h2>{this.state.time}</h2>\n        </React.Fragment>\n        )// 注意  只能return一个标签  我们这里用React.Fragment只是充当一个容器，但是不会渲染出来\n    };\n    */\n\n\n    //初始化   \n    //constructor(){}  会在其装载之前被调用  \n\n    //挂载\n    // getDerivedStateFromProps(){\n    //    组件实例化后或接受新属性时将被调用\n    // }\n    //render()\n    // componentDidMount(){\n    //       组件挂载后立即调用，发送请求的好地方\n    // }\n    //更新\n    // getDerivedStateFromProps(){\n    //     组件实例化后或接受新属性时将被调用\n    // }\n    // shouldComponentUpdate(){\n    //     当接收到新属性或状态时，是否要更新\n    // }\n    //render()\n    // getSnapshotBeforeUpdate(){\n    //     在最新的渲染输出提交给DOM前将会立即调用\n    // }\n    // componentDidCatch(){\n    //     组件更新后立即调用\n    // }\n    //卸载\n    // componentWillUnmount(){\n\n    // }\n//}\n//ReactDOM.render(<Hello word=\" 一直走花路\"/>,document.getElementById('root'))"],"sourceRoot":""}